
model{
  # Priors
  alpha_Int ~ dunif(-5,5)
  alpha_Y10 ~ dunif(-5,5)
  alpha_Y12 ~ dunif(-5,5)
  alpha_Y13 ~ dunif(-5,5)
  alpha_Y19 ~ dunif(-5,5)
  alpha_Y24 ~ dunif(-5,5)
  alpha_Y25 ~ dunif(-5,5)
  beta_Int ~ dunif(-5,5)
  beta_fieldS ~ dunif(-5,5) # field covariate
  beta_Y10 ~ dunif(-5,5) # Y10 covariate
  beta_Y12 ~ dunif(-5,5) # Y12 covariate
  beta_Y13 ~ dunif(-5,5) # Y13 covariate
  beta_Y19 ~ dunif(-5,5) # Y19 covariate
  beta_Y24 ~ dunif(-5,5) # Y24 covariate
  beta_Y25 ~ dunif(-5,5) # Y25 covariate
  beta_fld10 ~ dunif(-5,5) # interaction covariate
  beta_fld12 ~ dunif(-5,5) # interaction covariate
  beta_fld13 ~ dunif(-5,5) # interaction covariate
  beta_fld19 ~ dunif(-5,5) # interaction covariate
  beta_fld24 ~ dunif(-5,5) # interaction covariate
  beta_fld25 ~ dunif(-5,5) # interaction covariate

  for(i in 1:nind){
    dclass[i] ~ dcat(fc[site[i],]) # Part 1 of HM
  }
  for(s in 1:nsites){
    # Construct cell probabilities for nD distance bands
    for(g in 1:nD){                # midpt = mid-point of each band
      log(p[s,g]) <- -midpt[g] * midpt[g] / (2 * sigma[s] * sigma[s])
      pi[s,g] <- ((2 * midpt[g] ) / (B * B)) * delta # prob. per interval
      f[s,g] <- p[s,g] * pi[s,g]
      fc[s,g] <- f[s,g] / pcap[s]
    }
    pcap[s] <- sum(f[s,])           # Pr(capture): sum of rectangular areas

    ncap[s] ~ dbin(pcap[s], N[s])   # Part 2 of HM
    N[s] ~ dpois(lambda[s])         # Part 3 of HM
    
    # linear model of abundance
    log(lambda[s]) <- beta_Int + beta_fieldS * field[s] + 
        beta_Y10 * Y10[s] + beta_Y12 * Y12[s] +
        beta_Y13 * Y13[s] + beta_Y19 * Y19[s] + 
        beta_Y24 * Y24[s] + beta_Y25 * Y25[s] +
        beta_fld10 * field[s] * Y10[s] +
        beta_fld12 * field[s] * Y12[s] +
        beta_fld13 * field[s] * Y13[s] +
        beta_fld19 * field[s] * Y19[s] +
        beta_fld24 * field[s] * Y24[s] +
        beta_fld25 * field[s] * Y25[s]
    
    # linear model of detection
    log(sigma[s]) <- alpha_Int + alpha_Y10 * Y10[s] + alpha_Y12 * Y12[s] +
                      alpha_Y13 * Y13[s] + alpha_Y19 * Y19[s] +
                        alpha_Y24 * Y24[s] + alpha_Y25 * Y25[s]
  }

  # Derived parameters
  
  # lambda: mean count per sample
  lam.S.Y10 <- exp(beta_Int + beta_fieldS + beta_Y10 + beta_fld10)/4
  lam.K.Y10 <- exp(beta_Int + beta_Y10)/4
  lam.S.Y12 <- exp(beta_Int + beta_fieldS + beta_Y12 + beta_fld12)/4
  lam.K.Y12 <- exp(beta_Int + beta_Y12)/4
  lam.S.Y13 <- exp(beta_Int + beta_fieldS + beta_Y13 + beta_fld13)/4
  lam.K.Y13 <- exp(beta_Int + beta_Y13)/4
  lam.S.Y18 <- exp(beta_Int + beta_fieldS)/4
  lam.K.Y18 <- exp(beta_Int)/4
  lam.S.Y19 <- exp(beta_Int + beta_fieldS + beta_Y19 + beta_fld19)/4
  lam.K.Y19 <- exp(beta_Int + beta_Y19)/4
  lam.S.Y24 <- exp(beta_Int + beta_fieldS + beta_Y24 + beta_fld24)/4
  lam.K.Y24 <- exp(beta_Int + beta_Y24)/4
  lam.S.Y25 <- exp(beta_Int + beta_fieldS + beta_Y25 + beta_fld25)/4
  lam.K.Y25 <- exp(beta_Int + beta_Y25)/4
  
  # annual sigma for half-normal detection function
  sigma10 <- sigma[1]
  sigma12 <- sigma[20]
  sigma13 <- sigma[39]
  sigma18 <- sigma[58]
  sigma19 <- sigma[77]
  sigma24 <- sigma[96]
  sigma25 <- sigma[115]
}

