
model{

  # Detection model priors
  alpha_Int ~ dunif(-10,10)    # overall intercept for log(sigma)

  # Random (partial-pooling) year effects for sigma
  for(t in 1:nYears){
    alpha_year[t] ~ dnorm(0, tau_year)    # year-level deviations (mean 0)
  }
  tau_year <- pow(sd_year, -2)
  sd_year ~ dunif(0, 5)   # weakly informative prior on year SD
  
  # Abundance model priors
  beta_Int ~ dunif(-10,10)
  beta_fieldS ~ dunif(-10,10) # field covariate
  beta_Y10 ~ dunif(-10,10) # Y10 covariate
  beta_Y12 ~ dunif(-10,10) # Y12 covariate
  beta_Y13 ~ dunif(-10,10) # Y13 covariate
  beta_Y19 ~ dunif(-10,10) # Y19 covariate
  beta_Y24 ~ dunif(-10,10) # Y24 covariate
  beta_Y25 ~ dunif(-10,10) # Y25 covariate
  beta_fld10 ~ dunif(-10,10) # interaction covariate
  beta_fld12 ~ dunif(-10,10) # interaction covariate
  beta_fld13 ~ dunif(-10,10) # interaction covariate
  beta_fld19 ~ dunif(-10,10) # interaction covariate
  beta_fld24 ~ dunif(-10,10) # interaction covariate
  beta_fld25 ~ dunif(-10,10) # interaction covariate

  for(i in 1:nind){
    dclass[i] ~ dcat(fc[site[i],]) # Part 1 of HM
  }
  for(s in 1:nsites){
    # Construct cell probabilities for nD distance bands
    for(g in 1:nD){                # midpt = mid-point of each band
      log(p[s,g]) <- -midpt[g] * midpt[g] / (2 * sigma[s] * sigma[s])
      pi[s,g] <- ((2 * midpt[g] ) / (B * B)) * delta # prob. per interval
      f[s,g] <- p[s,g] * pi[s,g]
      fc[s,g] <- f[s,g] / pcap[s]
    }
    pcap[s] <- sum(f[s,])           # Pr(capture): sum of rectangular areas

    ncap[s] ~ dbin(pcap[s], N[s])   # Part 2 of HM
    N[s] ~ dpois(lambda[s])         # Part 3 of HM
    
    # linear model of abundance
    log(lambda[s]) <- beta_Int + beta_fieldS * field[s] + 
        beta_Y10 * Y10[s] + beta_Y12 * Y12[s] +
        beta_Y13 * Y13[s] + beta_Y19 * Y19[s] + 
        beta_Y24 * Y24[s] + beta_Y25 * Y25[s] +
        beta_fld10 * field[s] * Y10[s] +
        beta_fld12 * field[s] * Y12[s] +
        beta_fld13 * field[s] * Y13[s] +
        beta_fld19 * field[s] * Y19[s] +
        beta_fld24 * field[s] * Y24[s] +
        beta_fld25 * field[s] * Y25[s]
    
    # linear model of detection
    log(sigma[s]) <- alpha_Int + alpha_year[ yearIndex[s] ]
  }

  # Derived parameters
  
  # lambda: mean count per sample
  lam.S.Y10 <- exp(beta_Int + beta_fieldS + beta_Y10 + beta_fld10)/4
  lam.K.Y10 <- exp(beta_Int + beta_Y10)/4
  lam.S.Y12 <- exp(beta_Int + beta_fieldS + beta_Y12 + beta_fld12)/4
  lam.K.Y12 <- exp(beta_Int + beta_Y12)/4
  lam.S.Y13 <- exp(beta_Int + beta_fieldS + beta_Y13 + beta_fld13)/4
  lam.K.Y13 <- exp(beta_Int + beta_Y13)/4
  lam.S.Y18 <- exp(beta_Int + beta_fieldS)/4
  lam.K.Y18 <- exp(beta_Int)/4
  lam.S.Y19 <- exp(beta_Int + beta_fieldS + beta_Y19 + beta_fld19)/4
  lam.K.Y19 <- exp(beta_Int + beta_Y19)/4
  lam.S.Y24 <- exp(beta_Int + beta_fieldS + beta_Y24 + beta_fld24)/4
  lam.K.Y24 <- exp(beta_Int + beta_Y24)/4
  lam.S.Y25 <- exp(beta_Int + beta_fieldS + beta_Y25 + beta_fld25)/4
  lam.K.Y25 <- exp(beta_Int + beta_Y25)/4
  
  # annual sigma for half-normal detection function
  sigma10 <- sigma[1]
  sigma12 <- sigma[20]
  sigma13 <- sigma[39]
  sigma18 <- sigma[58]
  sigma19 <- sigma[77]
  sigma24 <- sigma[96]
  sigma25 <- sigma[115]
}
